{"version":3,"sources":["../../../../../assets/Script/prefab/assets/Script/prefab/cube.js"],"names":["cc","Class","extends","Component","properties","level","labelLevel","Label","state","default","Normal","type","onLoad","node","on","Node","EventType","TOUCH_START","onTouchStart","TOUCH_MOVE","onTouchMove","TOUCH_END","onTouchEnd","onLevelUp","moveCtl","up","down","left","right","string","init","edges","start","setState","update","dt","Bombing","removeFromParent","touch","Touched","getComponent","PhysicsCollider","body","awake","RigidBodyType","Dynamic","touchPos","parent","convertTouchToNodeSpaceAR","position","onBeginContact","contact","selfCollider","otherCollider","cube1","cube2","FallingDown","emit","onPreSolve"],"mappings":"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","file":"cube.js","sourceRoot":"../../../../../assets/Script/prefab","sourcesContent":["// Learn cc.Class:\n//  - [Chinese] http://docs.cocos.com/creator/manual/zh/scripting/class.html\n//  - [English] http://www.cocos2d-x.org/docs/creator/en/scripting/class.html\n// Learn Attribute:\n//  - [Chinese] http://docs.cocos.com/creator/manual/zh/scripting/reference/attributes.html\n//  - [English] http://www.cocos2d-x.org/docs/creator/en/scripting/reference/attributes.html\n// Learn life-cycle callbacks:\n//  - [Chinese] http://docs.cocos.com/creator/manual/zh/scripting/life-cycle-callbacks.html\n//  - [English] http://www.cocos2d-x.org/docs/creator/en/scripting/life-cycle-callbacks.html\n// import {CubeState} from './color-cube';\nimport {CubeState} from \"../consts\";\ncc.Class({\n  extends: cc.Component,\n\n  properties: {\n    level: 1,\n    labelLevel:cc.Label,\n    state:{\n      default:CubeState.Normal,\n      type:CubeState\n    },\n  },\n\n  // LIFE-CYCLE CALLBACKS:\n\n  onLoad() {\n    this.node.on(cc.Node.EventType.TOUCH_START,this.onTouchStart,this);\n    this.node.on(cc.Node.EventType.TOUCH_MOVE,this.onTouchMove,this);\n    this.node.on(cc.Node.EventType.TOUCH_END,this.onTouchEnd,this);\n\n    this.node.on(\"level-up\",this.onLevelUp,this);\n\n    this.moveCtl={\n      up:true,\n      down:true,\n      left:true,\n      right:true\n    }\n  },\n\n  onLevelUp(){\n    this.level++;\n    this.labelLevel.string=this.level;\n  },\n\n\n  init(edges) {\n    this.labelLevel.string=this.level;\n  },\n\n  start() {\n\n  },\n\n  setState(state) {\n    if (this.state===state){\n      return;\n    }\n    this.state=state;\n  },\n\n  update(dt) {\n    if (this.state === CubeState.Bombing) {\n      this.node.removeFromParent();\n    }\n  },\n\n  onTouchStart(touch){\n    this.setState(CubeState.Touched);\n    this.node.getComponent(cc.PhysicsCollider).body.awake=true;\n    this.node.getComponent(cc.PhysicsCollider).body.type=cc.RigidBodyType.Dynamic;\n\n  },\n\n  onTouchEnd(touch){\n    // this.setState(CubeState.FallingDown);\n\n  },\n\n  onTouchMove(touch){\n    let touchPos=this.node.parent.convertTouchToNodeSpaceAR(touch);\n    this.node.position=touchPos;\n    // let diff=cc.pSub(touchPos,this.node.position);\n    // this.moveCube(diff,touchPos);\n  },\n\n\n\n  // 只在两个碰撞体开始接触时被调用一次\n  onBeginContact: function (contact, selfCollider, otherCollider) {\n    // this.node.getComponent(cc.PhysicsCollider).body.type=cc.RigidBodyType.Static;\n\n    let cube1=selfCollider.node.getComponent(\"cube\");\n    let cube2=otherCollider.node.getComponent(\"cube\");\n    if (!cube1||!cube2){\n      return;\n    }\n    if (cube1.level !== cube2.level) {\n      return;\n    }\n    if (cube1.state === CubeState.Bombing) {\n      return;\n    }\n\n    if (cube1.state===CubeState.Touched||cube1.state===CubeState.FallingDown){\n      cube1.setState(CubeState.Bombing);\n      cube2.node.emit(\"level-up\");\n    }\n    // contact.disabledOnce=true;\n    // selfCollider.body.type=cc.RigidBodyType.Kinematic;\n  },\n\n  // 每次将要处理碰撞体接触逻辑时被调用\n  onPreSolve: function (contact, selfCollider, otherCollider) {\n    // if (otherCollider.node.getComponent(\"cube\")) {\n    //   contact.disabledOnce=true;\n    // }\n\n\n  },\n\n\n  // moveCube(diff,touchPos){\n  //   let max=gameManager.getLimitPosition(touchPos,this.node);\n  //   if ((diff.x>0&&this.moveCtl.right)||(diff.x<0&&this.moveCtl.left)){\n  //     this.node.x+=diff.x;\n  //     if (diff.x>0){\n  //       this.node.x=Math.min(this.node.x,max.x);\n  //     } else{\n  //       this.node.x=Math.max(this.node.x,max.x);\n  //     }\n  //   }\n  //\n  //   if ((diff.y>0&&this.moveCtl.up)||(diff.y<0&&this.moveCtl.down)){\n  //     this.node.y+=diff.y;\n  //     if (diff.y>0){\n  //       this.node.y=Math.min(this.node.y,max.y);\n  //     } else{\n  //       this.node.y=Math.max(this.node.y,max.y);\n  //     }\n  //   }\n  // },\n  //\n  // updateMoveDir(otherNode,selfNode){\n  //   let otherBox=otherNode.getBoundingBox();\n  //   let selfBox=selfNode.getBoundingBox();\n  //   if (Math.abs((otherBox.x - selfBox.x)) > selfBox.width/2) { //横向碰撞\n  //     if((selfBox.x-otherBox.x)<=selfBox.width&&(selfBox.x-otherBox.x)>0){\n  //       this.moveCtl.left=false;\n  //     }else{\n  //       this.moveCtl.left=true;\n  //     }\n  //\n  //     if((otherBox.x-selfBox.x)<=selfBox.width&&(otherBox.x-selfBox.x)>0){\n  //       this.moveCtl.right=false;\n  //     }else{\n  //       this.moveCtl.right=true;\n  //     }\n  //   }else{\n  //     if((otherBox.y-selfBox.y)<=selfBox.height&&(otherBox.y-selfBox.y)>0){\n  //       this.moveCtl.up=false;\n  //     }else{\n  //       this.moveCtl.up=true;\n  //     }\n  //\n  //     if((selfBox.y-otherBox.y)<=selfBox.height&&(selfBox.y-otherBox.y)>0){\n  //       this.moveCtl.down=false;\n  //     }else{\n  //       this.moveCtl.down=true;\n  //     }\n  //   }\n  // },\n  //\n  // onCollisionEnter: function (other, self) {\n  //   cc.log(\"on collision enter\");\n  //   this.updateMoveDir(other.node,self.node);\n  // },\n  //\n  // onCollisionExit: function (other, self) {\n  //   cc.log(\"on collision exit\");\n  //   this.updateMoveDir(other.node,self.node);\n  // }\n});\n"]}